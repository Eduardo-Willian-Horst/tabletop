<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grid Infinita</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
        }

        #canvas {
            display: block;
            cursor: grab;
            width: 100%;
            height: 100%;
        }

        #canvas:active {
            cursor: grabbing;
        }

        .controls {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(30, 30, 30, 0.95);
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            z-index: 1000;
            min-width: 280px;
        }

        .controls h3 {
            color: #fff;
            margin-bottom: 15px;
            font-size: 18px;
            font-weight: 600;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            color: #aaa;
            margin-bottom: 8px;
            font-size: 13px;
            font-weight: 500;
        }

        .control-group input[type="color"] {
            width: 100%;
            height: 45px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            background: #2a2a2a;
        }

        .control-group input[type="file"] {
            width: 100%;
            padding: 10px;
            border: 2px dashed #4CAF50;
            border-radius: 8px;
            cursor: pointer;
            background: #2a2a2a;
            color: #aaa;
            font-size: 12px;
        }

        .control-group input[type="file"]:hover {
            border-color: #45a049;
            background: #333;
        }

        .control-group input[type="file"]::file-selector-button {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            background: #4CAF50;
            color: white;
            cursor: pointer;
            font-weight: 600;
            margin-right: 10px;
            transition: all 0.2s;
        }

        .control-group input[type="file"]::file-selector-button:hover {
            background: #45a049;
        }

        .control-group input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #2a2a2a;
            outline: none;
            -webkit-appearance: none;
        }

        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #4CAF50;
            cursor: pointer;
            transition: all 0.2s;
        }

        .control-group input[type="range"]::-webkit-slider-thumb:hover {
            background: #45a049;
            transform: scale(1.1);
        }

        .control-group input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #4CAF50;
            cursor: pointer;
            border: none;
            transition: all 0.2s;
        }

        .control-group input[type="range"]::-moz-range-thumb:hover {
            background: #45a049;
            transform: scale(1.1);
        }

        .value-display {
            display: inline-block;
            color: #4CAF50;
            font-weight: 600;
            margin-left: 8px;
        }

        button {
            width: 100%;
            padding: 12px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.2s;
            margin-top: 5px;
        }

        button:hover {
            background: #45a049;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);
        }

        button:active {
            transform: translateY(0);
        }

        .info {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(30, 30, 30, 0.95);
            padding: 15px 20px;
            border-radius: 8px;
            color: #aaa;
            font-size: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        .info span {
            color: #4CAF50;
            font-weight: 600;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div class="controls">
        <h3>‚öôÔ∏è Controles</h3>
        
        <div class="control-group">
            <label>Imagem de Fundo (Mapa)</label>
            <input type="file" id="bgImage" accept="image/*">
        </div>
        
        <div class="control-group">
            <label>
                Opacidade da Imagem
                <span class="value-display" id="imageOpacityValue">100%</span>
            </label>
            <input type="range" id="imageOpacity" min="0" max="100" value="100">
        </div>
        
        <div class="control-group">
            <label>
                Escala da Imagem
                <span class="value-display" id="imageScaleValue">1.0x</span>
            </label>
            <input type="range" id="imageScale" min="10" max="300" value="100">
        </div>
        
        <div class="control-group">
            <label>Cor do Background</label>
            <input type="color" id="bgColor" value="#1a1a1a">
        </div>
        
        <div class="control-group">
            <label>Cor da Grid</label>
            <input type="color" id="gridColor" value="#333333">
        </div>
        
        <div class="control-group">
            <label>
                Opacidade da Grid
                <span class="value-display" id="gridOpacityValue">100%</span>
            </label>
            <input type="range" id="gridOpacity" min="0" max="100" value="100">
        </div>
        
        <div class="control-group">
            <label>
                Tamanho da Grid
                <span class="value-display" id="gridSizeValue">50px</span>
            </label>
            <input type="range" id="gridSize" min="10" max="200" value="50">
        </div>
        
        <div class="control-group">
            <label>
                Espessura da Linha
                <span class="value-display" id="lineWidthValue">1px</span>
            </label>
            <input type="range" id="lineWidth" min="0.5" max="5" step="0.5" value="1">
        </div>
        
        <button id="removeImage">üóëÔ∏è Remover Imagem</button>
        <button id="resetView">üîÑ Resetar Visualiza√ß√£o</button>
    </div>
    
    <div class="info">
        <div>üñ±Ô∏è <span>Arraste</span> para mover | üîç <span>Scroll</span> para zoom</div>
        <div style="margin-top: 5px;">Zoom: <span id="zoomLevel">100%</span></div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // Configura√ß√£o do canvas
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            draw();
        }
        
        // Estado da visualiza√ß√£o
        let offsetX = 0;
        let offsetY = 0;
        let scale = 1;
        
        // Configura√ß√µes da grid
        let gridSize = 50;
        let lineWidth = 1;
        let bgColor = '#1a1a1a';
        let gridColor = '#333333';
        let gridOpacity = 1.0;
        
        // Configura√ß√µes da imagem
        let backgroundImage = null;
        let imageOpacity = 1.0;
        let imageScale = 1; // Escala da imagem em rela√ß√£o √† grid
        
        // Controle de arraste
        let isDragging = false;
        let lastX = 0;
        let lastY = 0;
        
        // Fun√ß√£o principal de desenho - OTIMIZADA
        function draw() {
            // Limpa o canvas (sempre ocupa tela inteira)
            ctx.fillStyle = bgColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Desenha a imagem de fundo se existir
            if (backgroundImage) {
                ctx.save();
                ctx.globalAlpha = imageOpacity;
                
                // Calcula a escala e posi√ß√£o da imagem
                const imgScale = scale * imageScale;
                const imgWidth = backgroundImage.width * imgScale;
                const imgHeight = backgroundImage.height * imgScale;
                
                // Desenha a imagem com offset e zoom
                ctx.drawImage(
                    backgroundImage,
                    offsetX,
                    offsetY,
                    imgWidth,
                    imgHeight
                );
                
                ctx.restore();
            }
            
            // Calcula o tamanho escalado da grid
            const scaledGridSize = gridSize * scale;
            
            // Calcula apenas as linhas vis√≠veis na viewport (em coordenadas da tela)
            const startX = Math.floor(-offsetX / scaledGridSize) * scaledGridSize + offsetX;
            const endX = canvas.width;
            const startY = Math.floor(-offsetY / scaledGridSize) * scaledGridSize + offsetY;
            const endY = canvas.height;
            
            // Desenha a grid com opacidade
            ctx.save();
            ctx.globalAlpha = gridOpacity;
            ctx.strokeStyle = gridColor;
            ctx.lineWidth = lineWidth;
            ctx.beginPath();
            
            // Desenha apenas linhas verticais vis√≠veis
            for (let x = startX; x <= endX; x += scaledGridSize) {
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
            }
            
            // Desenha apenas linhas horizontais vis√≠veis
            for (let y = startY; y <= endY; y += scaledGridSize) {
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
            }
            
            ctx.stroke();
            ctx.restore();
            
            // Atualiza display do zoom
            document.getElementById('zoomLevel').textContent = Math.round(scale * 100) + '%';
        }
        
        // Controle de mouse - Pan
        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastX = e.clientX;
            lastY = e.clientY;
        });
        
        canvas.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const deltaX = e.clientX - lastX;
                const deltaY = e.clientY - lastY;
                
                offsetX += deltaX;
                offsetY += deltaY;
                
                lastX = e.clientX;
                lastY = e.clientY;
                
                draw();
            }
        });
        
        canvas.addEventListener('mouseup', () => {
            isDragging = false;
        });
        
        canvas.addEventListener('mouseleave', () => {
            isDragging = false;
        });
        
        // Controle de zoom com scroll
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            
            const mouseX = e.clientX;
            const mouseY = e.clientY;
            
            // Posi√ß√£o do mouse no espa√ßo da grid (antes do zoom)
            const gridX = mouseX - offsetX;
            const gridY = mouseY - offsetY;
            
            // Ajusta o zoom
            const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
            const oldScale = scale;
            const newScale = Math.min(Math.max(scale * zoomFactor, 0.1), 10);
            
            // Ajusta o offset para manter o ponto do mouse na mesma posi√ß√£o da grid
            offsetX = mouseX - (gridX * newScale / oldScale);
            offsetY = mouseY - (gridY * newScale / oldScale);
            
            scale = newScale;
            draw();
        });
        
        // Controles da interface
        document.getElementById('bgImage').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        backgroundImage = img;
                        draw();
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
            }
        });
        
        document.getElementById('imageOpacity').addEventListener('input', (e) => {
            imageOpacity = parseInt(e.target.value) / 100;
            document.getElementById('imageOpacityValue').textContent = e.target.value + '%';
            draw();
        });
        
        document.getElementById('imageScale').addEventListener('input', (e) => {
            imageScale = parseInt(e.target.value) / 100;
            document.getElementById('imageScaleValue').textContent = imageScale.toFixed(1) + 'x';
            draw();
        });
        
        document.getElementById('bgColor').addEventListener('input', (e) => {
            bgColor = e.target.value;
            draw();
        });
        
        document.getElementById('gridColor').addEventListener('input', (e) => {
            gridColor = e.target.value;
            draw();
        });
        
        document.getElementById('gridOpacity').addEventListener('input', (e) => {
            gridOpacity = parseInt(e.target.value) / 100;
            document.getElementById('gridOpacityValue').textContent = e.target.value + '%';
            draw();
        });
        
        document.getElementById('gridSize').addEventListener('input', (e) => {
            gridSize = parseInt(e.target.value);
            document.getElementById('gridSizeValue').textContent = gridSize + 'px';
            draw();
        });
        
        document.getElementById('lineWidth').addEventListener('input', (e) => {
            lineWidth = parseFloat(e.target.value);
            document.getElementById('lineWidthValue').textContent = lineWidth + 'px';
            draw();
        });
        
        document.getElementById('removeImage').addEventListener('click', () => {
            backgroundImage = null;
            document.getElementById('bgImage').value = '';
            draw();
        });
        
        document.getElementById('resetView').addEventListener('click', () => {
            offsetX = 0;
            offsetY = 0;
            scale = 1;
            draw();
        });
        
        // Suporte para touch (mobile)
        let touchStartDistance = 0;
        let touchStartScale = 1;
        
        canvas.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) {
                isDragging = true;
                lastX = e.touches[0].clientX;
                lastY = e.touches[0].clientY;
            } else if (e.touches.length === 2) {
                isDragging = false;
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                touchStartDistance = Math.sqrt(dx * dx + dy * dy);
                touchStartScale = scale;
            }
        });
        
        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            
            if (e.touches.length === 1 && isDragging) {
                const deltaX = e.touches[0].clientX - lastX;
                const deltaY = e.touches[0].clientY - lastY;
                
                offsetX += deltaX;
                offsetY += deltaY;
                
                lastX = e.touches[0].clientX;
                lastY = e.touches[0].clientY;
                
                draw();
            } else if (e.touches.length === 2) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                scale = Math.min(Math.max(touchStartScale * (distance / touchStartDistance), 0.1), 10);
                draw();
            }
        }, { passive: false });
        
        canvas.addEventListener('touchend', () => {
            isDragging = false;
        });
        
        // Inicializa
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
    </script>
</body>
</html>

